## Pre-Case Array

> ### 1. 原地排序

原地算法
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

[01-in-place](algorithm/pre-case/array/01-in-place-algorithm.md)

> ### 2. 买卖股票的最佳时机 II

示例 1:

输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

[买卖股票最佳时机](algorithm/pre-case/array/02-买卖股票最佳时机2.md)

> ### 3. 数组翻转

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]

要求 时间复杂度 O(T) = O(1)

[03-数组反转](algorithm/pre-case/array/03-rotate-array.md)

> ### 04. 判断是否存在重复元素

给定一个整数数组，判断是否存在重复元素。

如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。

[04-exist-duplicate](algorithm/pre-case/array/04-exist-duplicate.md)

> ### 05-找到只出现一次的数字

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

[05-single-number](algorithm/pre-case/array/05-single-number.md)

> ### 06-两个数组的交集
>
> 给定两个数组，编写一个函数来计算它们的交集。
> 输入: nums1 = [1,2,2,1], nums2 = [2,2]
> 输出: [2,2]
> 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
> 输出: [4,9]

[06-intersect](algorithm/pre-case/array/06-intersect.md)

> ### 07-加一

给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1:

输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
示例 2:

输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。

[07-add-one](algorithm/pre-case/array/07-add-one.md)

> ### 08. 移动 0

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]

[08-move-zeroes](algorithm/pre-case/array/08-move-zeroes.md)




> ### 09. 数独是否 “独”

判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

如图所示： [图示](https://leetcode-cn.com/explore/featured/card/top-interview-questions-easy/1/array/30/)

[09-valid-sudo](algorithm/pre-case/array/09-valid-sudoku.md)


> ### 10. 图像(二维矩阵)翻转

 给定 
 matrix = 
 [
   [1,2,3],
   [4,5,6],
   [7,8,9]
 ],

 将 matrix **原地反转** 90°*，使其变为:
 [
   [7,4,1],
   [8,5,2],
   [9,6,3]
 ]

要求： **原地翻转**，不得使用额外空间！

[10-reverse-image](algorithm/pre-case/array/10-reverse-image.md)